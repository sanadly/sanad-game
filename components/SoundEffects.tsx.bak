'use client';

import { useEffect, useRef, useState } from 'react';
import { useGameStore } from '@/store/gameStore';

// Simple sound effect system using Web Audio API
export default function SoundEffects() {
  const stats = useGameStore((state) => state.stats);
  const prevStatsRef = useRef(stats);
  const [soundEnabled, setSoundEnabled] = useState(true);

  useEffect(() => {
    if (typeof window !== 'undefined') {
      const settings = localStorage.getItem('terra-nova-settings');
      if (settings) {
        const parsed = JSON.parse(settings);
        setSoundEnabled(parsed.soundEnabled !== false);
      }
    }
  }, []);

  useEffect(() => {
    if (!soundEnabled) return;

    // Only play sounds if stats actually changed (not on initial mount)
    const prevStats = prevStatsRef.current;
    let hasChanges = false;

    Object.entries(stats).forEach(([type, stat]) => {
      const prevStat = prevStats[type as keyof typeof prevStats];
      if (stat.value !== prevStat.value) {
        hasChanges = true;
      }
    });

    if (!hasChanges) {
      prevStatsRef.current = stats;
      return;
    }

    // Create audio context for sound effects
    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();

    const playSound = (frequency: number, duration: number, type: OscillatorType = 'sine') => {
      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
      } catch (error) {
        // Silently fail if audio context is not available
        console.debug('Audio context not available');
      }
    };

    // Check for stat increases (level up sounds)
    Object.entries(stats).forEach(([type, stat]) => {
      const prevStat = prevStats[type as keyof typeof prevStats];
      if (stat.value > prevStat.value) {
        // Play a pleasant chime for stat increases
        playSound(440, 0.1, 'sine');
        setTimeout(() => playSound(554, 0.1, 'sine'), 50);
        setTimeout(() => playSound(659, 0.1, 'sine'), 100);
      }
    });

    prevStatsRef.current = stats;

    return () => {
      try {
        audioContext.close();
      } catch (error) {
        // Ignore errors on cleanup
      }
    };
  }, [stats, soundEnabled]);

  return null;
}
